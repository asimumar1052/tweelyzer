import { AnalyzeTweetResponse } from '@/types/api';
import { formatExactTime, parseTwitterDate } from './date-utils';

export function generateTxtReport(data: AnalyzeTweetResponse): string {
  const createdAt = parseTwitterDate(data.created_at);
  
  // Safely parse the fact check timestamp
  let factCheckTime: Date;
  try {
    factCheckTime = new Date(data.fact_check.timestamp_utc);
    // Check if the date is valid
    if (isNaN(factCheckTime.getTime())) {
      console.warn('Invalid timestamp_utc, using current date:', data.fact_check.timestamp_utc);
      factCheckTime = new Date();
    }
  } catch (error) {
    console.warn('Error parsing timestamp_utc, using current date:', error);
    factCheckTime = new Date();
  }

  return `TWEELYZER ANALYSIS REPORT
${'='.repeat(50)}

TWEET INFORMATION
Author: ${data.author.name} (@${data.author.screen_name})${data.author.blue_verified ? ' ✓' : ''}
Created: ${formatExactTime(createdAt)}
Language: ${data.lang}
Tweet ID: ${data.id}

CONTENT
${data.text}

ENGAGEMENT METRICS
❤️ Likes: ${data.likes.toLocaleString()}
🔄 Retweets: ${data.retweets.toLocaleString()}
🔖 Bookmarks: ${data.bookmarks.toLocaleString()}
💬 Replies: ${data.replies.toLocaleString()}
📝 Quotes: ${data.quotes.toLocaleString()}

SENTIMENT ANALYSIS
Label: ${data.sentiment.label}
Confidence: ${(data.sentiment.confidence * 100).toFixed(1)}%

FACT-CHECK ANALYSIS
${'='.repeat(30)}
Contains Claim: ${data.is_claim ? 'Yes' : 'No'}
${data.is_claim ? `
Claim: ${data.fact_check.claim}
Verdict: ${data.fact_check.verdict}
Confidence: ${(data.fact_check.confidence * 100).toFixed(1)}%

SEARCH QUERIES USED
${data.fact_check.searched_queries.map(q => `• ${q}`).join('\n')}

RESULTS CONSIDERED: ${data.fact_check.results_considered}

SUPPORTING EVIDENCE (${data.fact_check.support.length})
${data.fact_check.support.length > 0 ? 
  data.fact_check.support.map((item, i) => `
${i + 1}. ${item.title}
   Source: ${item.url}
   Evidence: ${item.evidence}
   Confidence: ${(item.score * 100).toFixed(1)}%
`).join('') : 'None found'}

CONTRADICTING EVIDENCE (${data.fact_check.refute.length})
${data.fact_check.refute.length > 0 ? 
  data.fact_check.refute.map((item, i) => `
${i + 1}. ${item.title}
   Source: ${item.url}
   Evidence: ${item.evidence}
   Confidence: ${(item.score * 100).toFixed(1)}%
`).join('') : 'None found'}

NEUTRAL EVIDENCE (${data.fact_check.neutral.length})
${data.fact_check.neutral.length > 0 ? 
  data.fact_check.neutral.map((item, i) => `
${i + 1}. ${item.title}
   Source: ${item.url}
   Evidence: ${item.evidence}
   Confidence: ${(item.score * 100).toFixed(1)}%
`).join('') : 'None found'}

ANALYSIS NOTES
${data.fact_check.notes}` : ''}

${'='.repeat(50)}
Analysis generated on: ${formatExactTime(factCheckTime)}
Generated by Tweelyzer - AI-Powered Tweet Analysis
`;
}

export function downloadTxtFile(content: string, filename: string): void {
  try {
    // Method 1: Standard blob download (most compatible)
    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
    
    // Check if we're in a browser environment
    if (typeof window === 'undefined') {
      console.error('Download not available - not in browser environment');
      return;
    }
    
    // Modern browsers
    if (window.navigator && (window.navigator as any).msSaveBlob) {
      // Internet Explorer
      (window.navigator as any).msSaveBlob(blob, `${filename}.txt`);
      console.log(`IE download initiated for: ${filename}.txt`);
      return;
    }
    
    // Standard approach for modern browsers
    if (window.URL && window.URL.createObjectURL) {
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      
      // Set attributes
      link.href = url;
      link.download = `${filename}.txt`;
      link.setAttribute('target', '_blank');
      link.style.display = 'none';
      
      // Add to DOM, click, and remove
      document.body.appendChild(link);
      
      // Force click event
      if (link.click) {
        link.click();
      } else {
        // Fallback for some browsers
        const event = new MouseEvent('click', {
          view: window,
          bubbles: true,
          cancelable: true
        });
        link.dispatchEvent(event);
      }
      
      // Clean up after a short delay
      setTimeout(() => {
        if (document.body.contains(link)) {
          document.body.removeChild(link);
        }
        URL.revokeObjectURL(url);
      }, 100);
      
      console.log(`Download initiated for: ${filename}.txt`);
      return;
    }
    
    // Fallback: Data URI method
    const dataUri = 'data:text/plain;charset=utf-8,' + encodeURIComponent(content);
    const link = document.createElement('a');
    link.href = dataUri;
    link.download = `${filename}.txt`;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    console.log(`Fallback download initiated for: ${filename}.txt`);
    
  } catch (error) {
    console.error('All download methods failed:', error);
    
    // Ultimate fallback: Open in new window
    try {
      const newWindow = window.open('', '_blank');
      if (newWindow) {
        newWindow.document.write(`<pre>${content}</pre>`);
        newWindow.document.title = `${filename}.txt`;
        console.log('Opened content in new window - please save manually');
      } else {
        // Show content in an alert as last resort
        const truncatedContent = content.length > 1000 
          ? content.substring(0, 1000) + '\n\n... (truncated)'
          : content;
        
        alert(`Download failed. Here's your report content:\n\n${truncatedContent}\n\nPlease copy and save manually as ${filename}.txt`);
      }
    } catch (finalError) {
      console.error('Final fallback also failed:', finalError);
      alert(`Download completely failed. Please check browser console for details.`);
    }
  }
}